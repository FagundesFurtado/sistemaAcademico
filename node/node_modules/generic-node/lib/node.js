"use strict";

var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var EventEmitter = require("events").EventEmitter;

/**
* Represents a node.
*
* @class
* @implements {EventEmitter}
*/

var Node = (function (EventEmitter) {
	/**
 * The constructor. Takes no parameters.
 *
 * @public
 * @constructor
 */

	function Node() {
		_classCallCheck(this, Node);

		// set instance values
		this._isNode = true;
		this.parent = null;
		this.children = [];
	}

	_inherits(Node, EventEmitter);

	_prototypeProperties(Node, null, {
		add: {

			/**
   * Adds a child node to this node.
   * If the specified node is already a child of a node it will not be added.
   *
   * @public
   * @param node {Node} the node to be added
   * @fires Node#added
   * @returns {boolean} true if the node was added; otherwise false
   */

			value: function add(node) {
				// make sure the node doesn't already have a parent and is an instance of Node
				if (!node._isNode || node.isChild()) {
					return false;
				} // set its parent
				node.parent = this;
				// add it to our children
				this.children.push(node);
				/**
    * Added event.
    * Emitted when a node is added to this node.
    *
    * @event Node#added
    * @type {Node}
    * @property {Node} the node that was added
    */
				this.emit("added", node);
				return true;
			},
			writable: true,
			configurable: true
		},
		remove: {

			/**
   * Removes a child node from this node.
   *
   * @public
   * @param node {Node} the node to be removed
   * @fires Node#removed
   * @returns {boolean} true if the node was removed; otherwise false
   */

			value: function remove(node) {
				// make sure the node is a Node and we are the parent of the node
				if (!node._isNode || this.children.indexOf(node) === -1) {
					return false;
				} // unset its parent
				node.parent = null;
				// remove the node from our children
				this.children.splice(this.children.indexOf(node), 1);
				/**
    * Removed event.
    * Emitted when a node is removed from this node.
    *
    * @event Node#removed
    * @type {Node}
    * @property {Node} the node that was removed
    */
				this.emit("removed", node);
				return true;
			},
			writable: true,
			configurable: true
		},
		isChild: {

			/**
   * Checks if this node is a child of another node.
   *
   * @public
   * @returns {boolean} true if this node is a child of another node; otherwise false
   */

			value: function isChild() {
				// check if we have a parent
				return this.parent !== null;
			},
			writable: true,
			configurable: true
		}
	});

	return Node;
})(EventEmitter);

module.exports = Node;